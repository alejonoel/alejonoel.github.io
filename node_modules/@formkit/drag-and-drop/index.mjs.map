{"version":3,"sources":["../src/utils.ts","../src/plugins/multiDrag/index.ts","../src/plugins/animations/index.ts","../src/plugins/multiDrag/plugins/selections/index.ts","../src/index.ts"],"sourcesContent":["import type {\n  Node,\n  NodeEventData,\n  NodeFromPoint,\n  ParentFromPoint,\n  EventHandlers,\n  ParentData,\n} from \"./types\";\n\nimport { parents, nodes } from \"./index\";\n\nfunction splitClass(className: string): Array<string> {\n  return className.split(\" \").filter((x) => x);\n}\n\n/**\n * Check to see if code is running in a browser.\n *\n * @internal\n */\nexport const isBrowser = typeof window !== \"undefined\";\n\nexport function addClass(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined,\n  omitAppendPrivateClass = false\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  if (classNames.includes(\"longTouch\")) return;\n\n  for (const node of els) {\n    if (!isNode(node) || !nodes.has(node)) {\n      node.classList.add(...classNames);\n\n      continue;\n    }\n\n    const privateClasses = [];\n\n    const nodeData = nodes.get(node);\n\n    if (!nodeData) continue;\n\n    for (const className of classNames) {\n      if (!node.classList.contains(className)) {\n        node.classList.add(className);\n      } else if (\n        node.classList.contains(className) &&\n        omitAppendPrivateClass === false\n      ) {\n        privateClasses.push(className);\n      }\n    }\n\n    nodeData.privateClasses = privateClasses;\n\n    nodes.set(node, nodeData);\n  }\n}\n\nexport function removeClass(\n  els: Array<Node | HTMLElement | Element>,\n  className: string | undefined\n) {\n  if (!className) return;\n\n  const classNames = splitClass(className);\n\n  if (!classNames.length) return;\n\n  for (const node of els) {\n    if (!isNode(node)) {\n      node.classList.remove(...classNames);\n      continue;\n    }\n\n    const nodeData = nodes.get(node);\n\n    if (!nodeData) continue;\n    for (const className of classNames) {\n      if (!nodeData.privateClasses.includes(className)) {\n        node.classList.remove(className);\n      }\n    }\n  }\n}\n\n/**\n * Used for getting the closest scrollable parent of a given element.\n *\n * @param node - The element to get the closest scrollable parent of.\n *\n * @internal\n */\nexport function getScrollParent(\n  node: HTMLElement | null\n): HTMLElement | undefined {\n  if (node == null) return undefined;\n\n  if (node.scrollHeight > node.clientHeight) {\n    return node;\n  } else if (node.parentNode instanceof HTMLElement) {\n    return getScrollParent(node.parentNode);\n  }\n\n  return undefined;\n}\n\n/**\n * Used for setting a single event listener on x number of events for a given\n * element.\n *\n * @param el - The element to set the event listener on.\n *\n * @param events - An array of events to set the event listener on.\n *\n * @param fn - The function to run when the event is triggered.\n *\n * @param remove - Whether or not to remove the event listener.\n *\n * @internal\n */\nexport function events(\n  el: Node | HTMLElement,\n  events: Array<string>,\n  fn: any,\n  remove = false\n) {\n  events.forEach((event) => {\n    remove ? el.removeEventListener(event, fn) : el.addEventListener(event, fn);\n  });\n}\n\nexport function getElFromPoint<T>(\n  eventData: NodeEventData<T>\n): NodeFromPoint<T> | ParentFromPoint<T> | undefined {\n  if (!(eventData.e instanceof TouchEvent)) return;\n\n  const newX = eventData.e.touches[0].clientX;\n\n  const newY = eventData.e.touches[0].clientY;\n\n  // TODO: Should be using elementFromPoint here, but it's not working as\n  // I would expect, need to look into this.\n  const els = document.elementsFromPoint(newX, newY);\n\n  if (!nodes) return;\n\n  for (const node of els) {\n    if (isNode(node) && nodes.has(node)) {\n      const targetNode = node;\n\n      const targetNodeData = nodes.get(targetNode);\n\n      const targetParentData = parents.get(targetNode.parentNode);\n\n      if (!targetNodeData || !targetParentData) return;\n\n      return {\n        node: {\n          el: targetNode,\n          data: targetNodeData,\n        },\n        parent: {\n          el: targetNode.parentNode,\n          data: targetParentData as ParentData<T>,\n        },\n      };\n    } else if (node instanceof HTMLElement) {\n      const parentData = parents.get(node);\n\n      if (parentData) {\n        return {\n          parent: {\n            el: node,\n            data: parentData as ParentData<T>,\n          },\n        };\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Checks to see that a given element and its parent node are instances of\n * HTML Elements.\n *\n * @param {unknown} el - The element to check.\n *\n * @returns {boolean} - Whether or not provided element is of type Node.\n */\nexport function isNode(el: unknown): el is Node {\n  return el instanceof HTMLElement && el.parentNode instanceof HTMLElement;\n}\n\n/**\n * Takes a given el and event handlers, assigns them, and returns the used abort\n * controller.\n *\n * @param el - The element to add the event listeners to.\n * @param events - The events to add to the element.\n * @returns - The abort controller used for the event listeners.\n */\nexport function addEvents(\n  el: Document | ShadowRoot | Node | HTMLElement,\n  events: EventHandlers | any\n): AbortController {\n  const abortController = new AbortController();\n  for (const eventName in events) {\n    const handler = events[eventName];\n    el.addEventListener(eventName, handler, {\n      signal: abortController.signal,\n      passive: false,\n    });\n  }\n  return abortController;\n}\n\nexport function copyNodeStyle(\n  sourceNode: Node,\n  targetNode: Node,\n  omitKeys = false\n) {\n  const computedStyle = window.getComputedStyle(sourceNode);\n\n  const omittedKeys = [\n    \"position\",\n    \"z-index\",\n    \"top\",\n    \"left\",\n    \"x\",\n    \"y\",\n    \"transform-origin\",\n    \"filter\",\n    \"-webkit-text-fill-color\",\n  ];\n\n  for (const key of Array.from(computedStyle)) {\n    if (omitKeys === false && key && omittedKeys.includes(key)) continue;\n\n    targetNode.style.setProperty(\n      key,\n      computedStyle.getPropertyValue(key),\n      computedStyle.getPropertyPriority(key)\n    );\n  }\n\n  for (const child of Array.from(sourceNode.children)) {\n    if (!isNode(child)) continue;\n\n    const targetChild = targetNode.children[\n      Array.from(sourceNode.children).indexOf(child)\n    ] as Node;\n\n    copyNodeStyle(child, targetChild, omitKeys);\n  }\n}\n\nexport function eventCoordinates(data: DragEvent | TouchEvent) {\n  return data instanceof DragEvent\n    ? { x: data.clientX, y: data.clientY }\n    : { x: data.touches[0].clientX, y: data.touches[0].clientY };\n}\n","import type {\n  Node,\n  NodeEventData,\n  NodeRecord,\n  DragState,\n  TouchState,\n  ParentData,\n  NodeDragEventData,\n  NodeTouchEventData,\n  DNDPluginData,\n  TearDownNodeData,\n  SetupNodeData,\n} from \"../../types\";\nimport type {\n  MultiDragConfig,\n  MultiDragParentConfig,\n  MultiDragState,\n} from \"./types\";\n\nimport {\n  parents,\n  handleLongTouch,\n  initDrag,\n  initTouch,\n  dragstartClasses,\n  handleTouchedNode,\n  end,\n  state,\n  resetState,\n} from \"../../index\";\nimport { addClass, removeClass, copyNodeStyle } from \"../../utils\";\n\nexport const multiDragState: MultiDragState<any> = {\n  selectedNodes: Array<NodeRecord<any>>(),\n\n  activeNode: undefined,\n\n  isTouch: false,\n};\n\nexport function multiDrag<T>(\n  multiDragConfig: Partial<MultiDragConfig<T>> = {}\n) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    const multiDragParentConfig = {\n      ...parentData.config,\n      multiDragConfig: multiDragConfig,\n    } as MultiDragParentConfig<T>;\n\n    return {\n      setup() {\n        multiDragParentConfig.handleDragstart =\n          multiDragConfig.multiHandleDragstart || multiHandleDragstart;\n\n        multiDragParentConfig.handleTouchstart =\n          multiDragConfig.multiHandleTouchstart || multiHandleTouchstart;\n\n        multiDragParentConfig.handleEnd =\n          multiDragConfig.multiHandleEnd || multiHandleEnd;\n\n        multiDragParentConfig.reapplyDragClasses =\n          multiDragConfig.multiReapplyDragClasses || multiReapplyDragClasses;\n\n        parentData.config = multiDragParentConfig;\n\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.tearDown?.();\n        });\n\n        multiDragParentConfig.multiDragConfig.plugins?.forEach((plugin) => {\n          plugin(parent)?.setup?.();\n        });\n      },\n\n      tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNodeRemap?.(data);\n        });\n      },\n\n      tearDownNode<T>(data: TearDownNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.tearDownNode?.(data);\n        });\n      },\n\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNodeRemap?.(data);\n        });\n      },\n\n      setupNode<T>(data: SetupNodeData<T>) {\n        multiDragParentConfig.multiDragConfig?.plugins?.forEach((plugin) => {\n          plugin(data.parent)?.setupNode?.(data);\n        });\n      },\n    } satisfies DNDPluginData;\n  };\n}\n\nfunction multiReapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\n  if (!state) return;\n\n  const dropZoneClass =\n    \"touchedNode\" in state\n      ? parentData.config.multiDragConfig.touchDropZoneClass\n      : parentData.config.multiDragConfig.dropZoneClass;\n\n  const draggedNodeEls = state.draggedNodes.map((x) => x.el);\n\n  if (!draggedNodeEls.includes(node)) return;\n\n  addClass([node], dropZoneClass, true);\n}\n\nfunction multiHandleEnd<T>(data: NodeEventData<T>) {\n  if (!state) return;\n\n  const isTouch = state && \"touchedNode\" in state;\n\n  if (isTouch && \"touchMoving\" in state && !state.touchMoving) return;\n\n  end(data, state);\n\n  selectionsEnd(data, state);\n\n  resetState();\n}\n\nfunction selectionsEnd<T>(\n  data: NodeEventData<T>,\n  state: DragState<T> | TouchState<T>\n) {\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  const selectedClass =\n    data.targetData.parent.data.config.selectionsConfig?.selectedClass;\n\n  const isTouch = state && \"touchedNode\" in state;\n\n  if (selectedClass) {\n    removeClass(\n      multiDragState.selectedNodes.map((x) => x.el),\n      selectedClass\n    );\n  }\n\n  multiDragState.selectedNodes = [];\n\n  multiDragState.activeNode = undefined;\n\n  const dropZoneClass = isTouch\n    ? multiDragConfig.selectionDropZoneClass\n    : multiDragConfig.touchSelectionDraggingClass;\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n}\n\nfunction multiHandleDragstart<T>(data: NodeEventData<T>) {\n  if (!(data.e instanceof DragEvent)) return;\n\n  dragstart({\n    e: data.e,\n    targetData: data.targetData,\n  });\n}\n\nfunction dragstart<T>(data: NodeDragEventData<T>) {\n  const dragState = initDrag(data);\n\n  multiDragState.isTouch = false;\n\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  const parentValues = data.targetData.parent.data.getValues(\n    data.targetData.parent.el\n  );\n\n  let selectedValues = multiDragState.selectedNodes.length\n    ? multiDragState.selectedNodes.map((x) => x.data.value)\n    : multiDragConfig.selections &&\n      multiDragConfig.selections(parentValues, data.targetData.parent.el);\n\n  if (selectedValues === undefined) return;\n\n  if (!selectedValues.includes(data.targetData.node.data.value)) {\n    selectedValues = [data.targetData.node.data.value, ...selectedValues];\n\n    const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n\n    addClass([data.targetData.node.el], selectionConfig?.selectedClass, true);\n\n    multiDragState.selectedNodes.push(data.targetData.node);\n  }\n\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n\n  dragState.originalZIndex = originalZIndex;\n\n  data.targetData.node.el.style.zIndex = \"9999\";\n\n  if (Array.isArray(selectedValues) && selectedValues.length) {\n    const targetRect = data.targetData.node.el.getBoundingClientRect();\n\n    const [x, y] = [\n      data.e.clientX - targetRect.left,\n      data.e.clientY - targetRect.top,\n    ];\n\n    stackNodes(handleSelections(data, selectedValues, dragState, x, y));\n  } else {\n    const config = data.targetData.parent.data.config;\n\n    dragstartClasses(\n      dragState.draggedNode.el,\n      config.draggingClass,\n      config.dropZoneClass\n    );\n  }\n}\n\nfunction multiHandleTouchstart<T>(data: NodeEventData<T>) {\n  if (!(data.e instanceof TouchEvent)) return;\n\n  touchstart({\n    e: data.e,\n    targetData: data.targetData,\n  });\n}\n\nfunction touchstart<T>(data: NodeTouchEventData<T>) {\n  const touchState = initTouch(data);\n\n  multiDragState.isTouch = true;\n\n  multiDragState.activeNode = data.targetData.node;\n\n  const multiDragConfig = data.targetData.parent.data.config.multiDragConfig;\n\n  const parentValues = data.targetData.parent.data.getValues(\n    data.targetData.parent.el\n  );\n\n  let selectedValues = [];\n\n  if (data.targetData.parent.data.config.selectionsConfig) {\n    selectedValues = multiDragState.selectedNodes.map((x) => x.data.value);\n  } else {\n    selectedValues =\n      multiDragConfig.selections &&\n      multiDragConfig.selections(parentValues, data.targetData.parent.el);\n  }\n\n  selectedValues = [data.targetData.node.data.value, ...selectedValues];\n\n  const selectionConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  addClass([data.targetData.node.el], selectionConfig?.selectedClass, true);\n\n  if (Array.isArray(selectedValues) && selectedValues.length) {\n    stackNodes(\n      handleSelections(\n        data,\n        selectedValues,\n        touchState,\n        touchState.touchStartLeft,\n        touchState.touchStartTop\n      )\n    );\n  } else {\n    handleTouchedNode(data, touchState);\n  }\n\n  handleLongTouch(data, touchState);\n}\n\nexport function handleSelections<T>(\n  data: NodeEventData<T>,\n  selectedValues: Array<T>,\n  state: DragState<T> | TouchState<T>,\n  x: number,\n  y: number\n) {\n  for (const child of data.targetData.parent.data.enabledNodes) {\n    if (child.el === state.draggedNode.el) continue;\n\n    if (!selectedValues.includes(child.data.value)) continue;\n\n    state.draggedNodes.push(child);\n  }\n\n  const config = data.targetData.parent.data.config.multiDragConfig;\n\n  const clonedEls = state.draggedNodes.map((x: NodeRecord<T>) => {\n    const el = x.el.cloneNode(true) as Node;\n\n    copyNodeStyle(x.el, el, true);\n\n    if (data.e instanceof DragEvent) addClass([el], config.draggingClass);\n\n    return el;\n  });\n\n  setTimeout(() => {\n    if (data.e instanceof DragEvent) {\n      addClass(\n        state.draggedNodes.map((x) => x.el),\n        config.dropZoneClass\n      );\n    }\n  });\n\n  state.clonedDraggedEls = clonedEls;\n\n  return { data, state, x, y };\n}\n\nexport function stackNodes<T>({\n  data,\n  state,\n  x,\n  y,\n}: {\n  data: NodeEventData<T>;\n  state: DragState<T> | TouchState<T>;\n  x: number;\n  y: number;\n}) {\n  const wrapper = document.createElement(\"div\");\n\n  for (const el of state.clonedDraggedEls) wrapper.append(el);\n\n  const { width } = state.draggedNode.el.getBoundingClientRect();\n\n  wrapper.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        width: ${width}px;\n        position: absolute;\n        z-index: 9999;\n        left: -9999px\n      `;\n\n  document.body.append(wrapper);\n\n  if (data.e instanceof DragEvent) {\n    data.e.dataTransfer?.setDragImage(wrapper, x, y);\n\n    setTimeout(() => {\n      wrapper.remove();\n    });\n  } else if (\"touchedNode\" in state) {\n    state.touchedNode = wrapper;\n  }\n}\n","import type { SetupNodeData, Node } from \"../../types\";\nimport type { AnimationsConfig } from \"./types\";\nimport { state, parents } from \"../../index\";\n\nexport function animations(animationsConfig: AnimationsConfig = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      setup() {\n        parentData.config.remapFinished = () => {};\n\n        const style = document.createElement(\"style\");\n\n        if (document.head.querySelector(\"[data-drag-and-drop]\")) return;\n\n        const duration = (animationsConfig.duration || 100) / 1000;\n\n        style.innerHTML = `\n          .drag-and-drop-slide-up {\n            animation-name: slideUp;\n            animation-duration: ${duration}s;\n          }\n\n          @keyframes slideUp {\n            from {\n              transform: translateY(100%);\n            }\n            to {\n              transform: translateY(0);\n            }\n          }\n\n          .drag-and-drop-slide-down {\n            animation-name: slideDown;\n            animation-duration: ${duration}s;\n          }\n\n          @keyframes slideDown {\n            from {\n              transform: translateY(-100%);\n            }\n            to {\n              transform: translateY(0%);\n            }\n          }\n\n          .drag-and-drop-slide-left {\n            animation-name: slideLeft;\n            animation-duration: ${duration}s;\n          }\n\n          @keyframes slideLeft {\n            from {\n              transform: translateX(100%);\n            }\n            to {\n              transform: translateX(0%);\n            }\n          }\n\n          .drag-and-drop-slide-right {\n            animation-name: slideRight;\n            animation-duration: ${duration}s;\n          }\n\n          @keyframes slideRight {\n            from {\n              transform: translateX(-100%);\n            }\n            to {\n              transform: translateX(0);\n            }\n          }\n        `;\n\n        style.setAttribute(\"type\", \"text/css\");\n\n        style.setAttribute(\"data-drag-and-drop\", \"true\");\n\n        document.head.append(style);\n      },\n\n      setupNodeRemap<T>(data: SetupNodeData<T>) {\n        if (!state) return;\n\n        if (data.nodeData.value === state.draggedNode.data.value) {\n          switch (state.incomingDirection) {\n            case \"below\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-up\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"above\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-down\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"left\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-right\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"right\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-left\",\n                animationsConfig.duration || 100\n              );\n              break;\n          }\n\n          return;\n        }\n\n        if (\n          !state.affectedNodes\n            .map((x) => x.data.value)\n            .includes(data.nodeData.value)\n        )\n          return;\n\n        const nodeRect = data.node.getBoundingClientRect();\n\n        const nodeIndex = state.affectedNodes.findIndex(\n          (x) => x.data.value === data.nodeData.value\n        );\n\n        const draggedNodeIndex = state.draggedNode.data.index;\n\n        const ascendingDirection = draggedNodeIndex >= state.targetIndex;\n\n        let adjacentNode;\n        if (ascendingDirection) {\n          adjacentNode = state.affectedNodes[nodeIndex + 1]\n            ? state.affectedNodes[nodeIndex + 1]\n            : state.affectedNodes[nodeIndex - 1];\n        } else {\n          adjacentNode = state.affectedNodes[nodeIndex - 1]\n            ? state.affectedNodes[nodeIndex - 1]\n            : state.affectedNodes[nodeIndex + 1];\n        }\n\n        if (adjacentNode) {\n          const xDiff = Math.abs(\n            nodeRect.x - adjacentNode.el.getBoundingClientRect().x\n          );\n\n          const yDiff = Math.abs(\n            nodeRect.y - adjacentNode.el.getBoundingClientRect().y\n          );\n\n          if (xDiff > yDiff && ascendingDirection) {\n            setClasses(\n              data.node,\n              \"drag-and-drop-slide-right\",\n              animationsConfig.duration || 100\n            );\n          } else if (xDiff > yDiff && !ascendingDirection) {\n            setClasses(\n              data.node,\n              \"drag-and-drop-slide-left\",\n              animationsConfig.duration || 100\n            );\n          }\n        } else {\n          switch (state.incomingDirection) {\n            case \"below\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-down\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"above\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-up\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"left\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-left\",\n                animationsConfig.duration || 100\n              );\n              break;\n            case \"right\":\n              setClasses(\n                data.node,\n                \"drag-and-drop-slide-right\",\n                animationsConfig.duration || 100\n              );\n              break;\n          }\n        }\n      },\n    };\n  };\n}\n\nfunction setClasses(node: Node, nodeClass: string, duration: number) {\n  node.classList.add(nodeClass);\n\n  setTimeout(() => {\n    if (!state) return;\n\n    state.swappedNodeValue = undefined;\n\n    node.classList.remove(nodeClass);\n\n    state.preventEnter = false;\n  }, duration);\n}\n","import type {\n  SetupNodeData,\n  NodeEventData,\n  TearDownNodeData,\n  ParentConfig,\n} from \"../../../../types\";\n\nimport type { SelectionsConfig } from \"./types\";\n\nimport { parents, nodeEventData } from \"../../../../index\";\n\nimport { addEvents, removeClass, addClass } from \"../../../../utils\";\n\nimport { multiDragState } from \"../../index\";\n\nexport function selections<T>(selectionsConfig: SelectionsConfig<T> = {}) {\n  return (parent: HTMLElement) => {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      setup() {\n        parentData.config.selectionsConfig = selectionsConfig;\n\n        parentData.config.handleClick =\n          selectionsConfig.handleClick || handleClick;\n\n        parentData.config.handleKeydown =\n          selectionsConfig.handleKeydown || handleKeydown;\n\n        selectionsConfig.clickawayDeselect =\n          selectionsConfig.clickawayDeselect === undefined\n            ? true\n            : selectionsConfig.clickawayDeselect;\n\n        if (!selectionsConfig.clickawayDeselect) return;\n\n        const rootAbortControllers = addEvents(parentData.config.root, {\n          click: handleRootClick.bind(null, parentData.config),\n        });\n\n        parentData.abortControllers[\"root\"] = rootAbortControllers;\n      },\n\n      tearDown() {\n        if (parentData.abortControllers.root) {\n          parentData.abortControllers.root.abort();\n        }\n      },\n\n      tearDownNode<T>(data: TearDownNodeData<T>) {\n        if (data.parentData.abortControllers.selectionsNode) {\n          data.parentData.abortControllers.selectionsNode.abort();\n        }\n      },\n\n      setupNode<T>(data: SetupNodeData<T>) {\n        const config = data.parentData.config;\n\n        data.node.setAttribute(\"tabindex\", \"0\");\n\n        const abortControllers = addEvents(data.node, {\n          click: nodeEventData(config.handleClick),\n          keydown: nodeEventData(config.handleKeydown),\n        });\n\n        data.nodeData.abortControllers[\"selectionsNode\"] = abortControllers;\n      },\n    };\n  };\n}\n\nfunction handleRootClick<T>(config: ParentConfig<T>) {\n  removeClass(\n    multiDragState.selectedNodes.map((x) => x.el),\n    config.selectionsConfig.selectedClass\n  );\n\n  multiDragState.selectedNodes = [];\n\n  multiDragState.activeNode = undefined;\n}\n\nfunction handleKeydown<T>(data: NodeEventData<T>) {\n  keydown(data);\n}\n\nfunction handleClick<T>(data: NodeEventData<T>) {\n  click(data);\n}\n\nfunction click<T>(data: NodeEventData<T>) {\n  data.e.stopPropagation();\n\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  const ctParentData = data.targetData.parent.data;\n\n  const selectedClass = selectionsConfig.selectedClass;\n\n  const targetNode = data.targetData.node;\n\n  let commandKey = false;\n\n  let shiftKey = false;\n\n  if (data.e instanceof MouseEvent) {\n    commandKey = data.e.ctrlKey || data.e.metaKey;\n    shiftKey = data.e.shiftKey;\n  }\n\n  if (shiftKey && multiDragState.isTouch === false) {\n    if (!multiDragState.activeNode) {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data,\n      };\n\n      for (let x = 0; x <= data.targetData.node.data.index; x++) {\n        multiDragState.selectedNodes.push(ctParentData.enabledNodes[x]);\n        if (selectedClass) {\n          addClass([ctParentData.enabledNodes[x].el], selectedClass, true);\n        }\n      }\n    } else {\n      const [minIndex, maxIndex] =\n        multiDragState.activeNode.data.index < data.targetData.node.data.index\n          ? [\n              multiDragState.activeNode.data.index,\n              data.targetData.node.data.index,\n            ]\n          : [\n              data.targetData.node.data.index,\n              multiDragState.activeNode.data.index,\n            ];\n\n      const selectedNodes = ctParentData.enabledNodes.slice(\n        minIndex,\n        maxIndex + 1\n      );\n\n      if (selectedNodes.length === 1) {\n        for (const node of multiDragState.selectedNodes) {\n          if (selectedClass) node.el.classList.remove(selectedClass);\n        }\n\n        multiDragState.selectedNodes = [\n          {\n            el: data.targetData.node.el,\n            data: data.targetData.node.data,\n          },\n        ];\n\n        multiDragState.activeNode = {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data,\n        };\n\n        if (selectedClass) {\n          data.targetData.node.el.classList.add(selectedClass);\n        }\n      }\n      for (let x = minIndex - 1; x >= 0; x--) {\n        if (\n          multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])\n        ) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            ),\n          ];\n\n          if (selectedClass) {\n            addClass([ctParentData.enabledNodes[x].el], selectedClass, true);\n          }\n        } else {\n          break;\n        }\n      }\n      for (let x = maxIndex; x < ctParentData.enabledNodes.length; x++) {\n        if (\n          multiDragState.selectedNodes.includes(ctParentData.enabledNodes[x])\n        ) {\n          multiDragState.selectedNodes = [\n            ...multiDragState.selectedNodes.filter(\n              (el) => el !== ctParentData.enabledNodes[x]\n            ),\n          ];\n          if (selectedClass) {\n            removeClass([ctParentData.enabledNodes[x].el], selectedClass);\n          }\n        } else {\n          break;\n        }\n      }\n      for (const node of selectedNodes) {\n        if (!multiDragState.selectedNodes.map((x) => x.el).includes(node.el)) {\n          multiDragState.selectedNodes.push(node);\n        }\n\n        if (selectedClass) {\n          addClass([node.el], selectedClass, true);\n        }\n      }\n    }\n  } else if (commandKey) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  } else if (!commandKey && multiDragState.isTouch === false) {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = {\n        el: data.targetData.node.el,\n        data: data.targetData.node.data,\n      };\n\n      if (selectedClass) {\n        for (const el of multiDragState.selectedNodes) {\n          removeClass([el.el], selectedClass);\n        }\n\n        addClass([data.targetData.node.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes = [\n        {\n          el: data.targetData.node.el,\n          data: data.targetData.node.data,\n        },\n      ];\n    }\n  } else {\n    if (multiDragState.selectedNodes.map((x) => x.el).includes(targetNode.el)) {\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el.el !== targetNode.el\n      );\n      if (selectedClass) {\n        removeClass([targetNode.el], selectedClass);\n      }\n    } else {\n      multiDragState.activeNode = targetNode;\n      if (selectedClass) {\n        addClass([targetNode.el], selectedClass, true);\n      }\n      multiDragState.selectedNodes.push(targetNode);\n    }\n  }\n}\n\nfunction keydown<T>(data: NodeEventData<T>) {\n  if (!(data.e instanceof KeyboardEvent)) return;\n\n  const keys = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n\n  if (!keys.includes(data.e.key) || !multiDragState.activeNode) return;\n\n  const selectionsConfig = data.targetData.parent.data.config.selectionsConfig;\n\n  data.e.preventDefault();\n\n  const parentData = data.targetData.parent.data;\n\n  const nodeData = data.targetData.node.data;\n\n  const enabledNodes = parentData.enabledNodes;\n\n  const moveUp = data.e.key === \"ArrowUp\" || data.e.key === \"ArrowLeft\";\n  const moveDown = data.e.key === \"ArrowDown\" || data.e.key === \"ArrowRight\";\n\n  const invalidKeydown =\n    (moveUp && nodeData.index === 0) ||\n    (moveDown && nodeData.index === enabledNodes.length - 1);\n\n  if (invalidKeydown) return;\n\n  const adjacentNode = enabledNodes[nodeData.index + (moveUp ? -1 : 1)];\n\n  const selectedClass = selectionsConfig.selectedClass;\n\n  if (!adjacentNode) return;\n\n  if (data.e.altKey) {\n    if (multiDragState.selectedNodes.length > 1) {\n      for (const el of multiDragState.selectedNodes) {\n        if (selectedClass && multiDragState.activeNode !== el) {\n          removeClass([el.el], selectedClass);\n        }\n      }\n\n      multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n        (el) => el !== multiDragState.activeNode\n      );\n    }\n    const parentValues = parentData.getValues(data.targetData.parent.el);\n\n    [\n      parentValues[nodeData.index],\n      parentValues[nodeData.index + (moveUp ? -1 : 1)],\n    ] = [\n      parentValues[nodeData.index + (moveUp ? -1 : 1)],\n      parentValues[nodeData.index],\n    ];\n\n    parentData.setValues(parentValues, data.targetData.parent.el);\n  } else if (data.e.shiftKey && multiDragState.isTouch === false) {\n    if (\n      !multiDragState.selectedNodes.map((x) => x.el).includes(adjacentNode.el)\n    ) {\n      multiDragState.selectedNodes.push(adjacentNode);\n\n      if (selectedClass) {\n        addClass([adjacentNode.el], selectedClass, true);\n      }\n\n      multiDragState.activeNode = adjacentNode;\n    } else {\n      if (\n        multiDragState.selectedNodes\n          .map((x) => x.el)\n          .includes(multiDragState.activeNode.el)\n      ) {\n        multiDragState.selectedNodes = multiDragState.selectedNodes.filter(\n          (el) => el !== multiDragState.activeNode\n        );\n\n        if (selectedClass) {\n          removeClass([multiDragState.activeNode.el], selectedClass);\n        }\n\n        multiDragState.activeNode = adjacentNode;\n      }\n    }\n  } else {\n    for (const el of multiDragState.selectedNodes) {\n      if (selectedClass && multiDragState.activeNode !== el) {\n        removeClass([el.el], selectedClass);\n      }\n    }\n\n    removeClass([multiDragState.activeNode.el], selectedClass);\n\n    multiDragState.selectedNodes = [adjacentNode];\n\n    addClass([adjacentNode.el], selectedClass, true);\n\n    multiDragState.activeNode = adjacentNode;\n  }\n\n  data.targetData.node.el.blur();\n\n  multiDragState.activeNode = adjacentNode;\n\n  multiDragState.activeNode.el.focus();\n}\n","import type {\n  DragAndDrop,\n  Node,\n  DNDPlugin,\n  NodeEventData,\n  TouchOverNodeEvent,\n  ParentsData,\n  NodesData,\n  DragState,\n  TouchState,\n  DragStateProps,\n  TouchStateProps,\n  NodeData,\n  ParentData,\n  SetupNodeData,\n  TearDownNodeData,\n  NodeTargetData,\n  ParentConfig,\n  ParentTargetData,\n  ParentEventData,\n  TouchOverParentEvent,\n  NodeDragEventData,\n  NodeTouchEventData,\n  NodeRecord,\n} from \"./types\";\nimport {\n  isBrowser,\n  addClass,\n  removeClass,\n  getElFromPoint,\n  isNode,\n  getScrollParent,\n  addEvents,\n  copyNodeStyle,\n  eventCoordinates,\n} from \"./utils\";\nexport { isBrowser };\nexport * from \"./types\";\nexport { multiDrag } from \"./plugins/multiDrag\";\nexport { animations } from \"./plugins/animations\";\n\nexport { selections } from \"./plugins/multiDrag/plugins/selections\";\n\nexport const nodes: NodesData<any> = new WeakMap<Node, NodeData<any>>();\n\nexport const parents: ParentsData<any> = new WeakMap<\n  HTMLElement,\n  ParentData<any>\n>();\n/**\n * The state of the drag and drop. Is undefined until either dragstart or\n * touchstart is called.\n */\nexport let state: DragState<any> | TouchState<any> | undefined = undefined;\n\nexport function resetState() {\n  state = undefined;\n}\n\n/**\n * @param {DragStateProps} dragStateProps - Attributes to update state with.\n *\n * @mutation - Updates state with node values.\n *\n * @returns void\n */\nexport function setDragState<T>(\n  dragStateProps: DragStateProps<T>\n): DragState<T> {\n  state = {\n    ascendingDirection: false,\n    incomingDirection: undefined,\n    enterCount: 0,\n    targetIndex: 0,\n    affectedNodes: [],\n    lastValue: undefined,\n    activeNode: undefined,\n    preventEnter: false,\n    clonedDraggedEls: [],\n    swappedNodeValue: false,\n    originalZIndex: undefined,\n    ...dragStateProps,\n  } as DragState<T>;\n\n  return state;\n}\n\nexport function setTouchState<T>(\n  dragState: DragState<T>,\n  touchStateProps: TouchStateProps\n): TouchState<T> {\n  state = {\n    ...dragState,\n    ...touchStateProps,\n  };\n\n  return state as TouchState<T>;\n}\n\nexport function dragStateProps<T>(\n  targetData: NodeTargetData<T>\n): DragStateProps<T> {\n  return {\n    draggedNode: {\n      el: targetData.node.el,\n      data: targetData.node.data,\n    },\n    draggedNodes: [\n      {\n        el: targetData.node.el,\n        data: targetData.node.data,\n      },\n    ],\n    initialIndex: targetData.node.data.index,\n    initialParent: {\n      el: targetData.parent.el,\n      data: targetData.parent.data,\n    },\n    lastParent: {\n      el: targetData.parent.el,\n      data: targetData.parent.data,\n    },\n  };\n}\n\nexport function performSort<T>(\n  state: DragState<T> | TouchState<T>,\n  data: NodeDragEventData<T> | NodeTouchEventData<T>\n) {\n  const draggedValues = dragValues(state);\n\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n\n  const newParentValues = [\n    ...targetParentValues.filter((x) => !draggedValues.includes(x)),\n  ];\n\n  newParentValues.splice(data.targetData.node.data.index, 0, ...draggedValues);\n\n  setParentValues(data.targetData.parent.el, data.targetData.parent.data, [\n    ...newParentValues,\n  ]);\n}\n\nexport function parentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>\n): Array<T> {\n  return [...parentData.getValues(parent)];\n}\n\nexport function setParentValues<T>(\n  parent: HTMLElement,\n  parentData: ParentData<T>,\n  values: Array<any>\n): void {\n  parentData.setValues(values, parent);\n}\n\nexport function dragValues<T>(state: DragState<T> | TouchState<T>): Array<T> {\n  return [...state.draggedNodes.map((x) => x.data.value)];\n}\n\n/**\n * Initializes the drag and drop functionality for a given parent.\n *\n * @param {DragAndDrop} dragAndDrop - The drag and drop configuration.\n * @param {HTMLElement} dragAndDrop.parent - The parent element.\n *\n * @returns void\n */\nexport function dragAndDrop<T>({\n  parent,\n  getValues,\n  setValues,\n  config = {},\n}: DragAndDrop<T>): void {\n  if (!isBrowser) return;\n\n  document.addEventListener(\"dragover\", (e) => {\n    e.preventDefault();\n  });\n\n  tearDown(parent);\n\n  const parentData: ParentData<T> = {\n    getValues,\n    setValues,\n    config: {\n      handleDragstart,\n      handleDragoverNode,\n      handleDragoverParent,\n      handleEnd,\n      handleTouchstart,\n      handleTouchmove,\n      handleTouchOverNode,\n      handleTouchOverParent,\n      performSort,\n      performTransfer,\n      root: document,\n      setupNode,\n      setupNodeRemap,\n      reapplyDragClasses,\n      tearDownNode,\n      tearDownNodeRemap,\n      remapFinished,\n      threshold: {\n        horizontal: 0,\n        vertical: 0,\n      },\n      ...config,\n    },\n    enabledNodes: [],\n    abortControllers: {},\n  };\n\n  setup(parent, parentData);\n\n  config.plugins?.forEach((plugin) => {\n    plugin(parent)?.tearDown?.();\n  });\n\n  config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(parent)?.setup?.();\n  });\n\n  remapNodes(parent, true);\n}\n\nexport function tearDown(parent: HTMLElement) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  if (parentData.abortControllers.mainParent) {\n    parentData.abortControllers.mainParent.abort();\n  }\n}\n\nfunction setup<T>(parent: HTMLElement, parentData: ParentData<T>): void {\n  const nodesObserver = new MutationObserver(nodesMutated);\n\n  nodesObserver.observe(parent, { childList: true });\n\n  parents.set(parent, parentData as any);\n\n  parentData.abortControllers.mainParent = addEvents(parent, {\n    dragover: parentEventData(parentData.config.handleDragoverParent),\n    touchOverParent: parentData.config.handleTouchOverParent,\n  });\n}\n\n/**\n * Called when the nodes of a given parent element are mutated.\n *\n * @param mutationList - The list of mutations.\n *\n * @returns void\n *\n * @internal\n */\nfunction nodesMutated(mutationList: MutationRecord[]) {\n  const parentEl = mutationList[0].target;\n\n  if (!(parentEl instanceof HTMLElement)) return;\n\n  remapNodes(parentEl);\n}\n/**\n * Remaps the data of the parent element's children.\n *\n * @param parent - The parent element.\n *\n * @returns void\n *\n * @internal\n */\nexport function remapNodes<T>(parent: HTMLElement, force?: boolean) {\n  const parentData = parents.get(parent);\n\n  if (!parentData) return;\n\n  const enabledNodes: Array<Node> = [];\n\n  const config = parentData.config;\n\n  for (let x = 0; x < parent.children.length; x++) {\n    const node = parent.children[x];\n\n    if (!isNode(node)) continue;\n\n    const nodeData = nodes.get(node);\n\n    // Only tear down the node if someone has explicitly called dragAndDrop.\n    if (force || !nodeData) {\n      config.tearDownNode({ node, parent, nodeData, parentData });\n    }\n\n    //config.tearDownNodeRemap({ node, parent, nodeData, parentData });\n\n    if (config.disabled) return;\n\n    if (!config.draggable || (config.draggable && config.draggable(node))) {\n      enabledNodes.push(node);\n    }\n  }\n\n  // TODO: maybe get rid of this?\n  if (\n    enabledNodes.length !== parentData.getValues(parent).length &&\n    !config.disabled\n  ) {\n    console.warn(\n      \"The number of enabled nodes does not match the number of values.\"\n    );\n\n    return;\n  }\n\n  const values = parentData.getValues(parent);\n\n  const enabledNodeRecords: Array<NodeRecord<T>> = [];\n\n  for (let x = 0; x < enabledNodes.length; x++) {\n    const node = enabledNodes[x];\n    const prevNodeData = nodes.get(node);\n    const nodeData = Object.assign(\n      prevNodeData ?? {\n        privateClasses: [],\n        abortControllers: {},\n      },\n      {\n        value: values[x],\n        index: x,\n      }\n    );\n\n    // TODO: maybe get rid of this — duplicate of the next if statement\n    if (state && nodeData.value === state.draggedNode.data.value) {\n      state.draggedNode.data = nodeData;\n\n      state.draggedNode.el = node;\n    }\n\n    if (\n      state &&\n      state.draggedNodes.map((x) => x.data.value).includes(nodeData.value)\n    ) {\n      const draggedNode = state.draggedNodes.find(\n        (x) => x.data.value === nodeData.value\n      );\n\n      if (draggedNode) draggedNode.el = node;\n    }\n\n    enabledNodeRecords.push({\n      el: node,\n      data: nodeData,\n    });\n\n    const setupNodeData = {\n      node,\n      parent,\n      parentData,\n      nodeData,\n    };\n\n    if (force || !prevNodeData) {\n      config.setupNode(setupNodeData);\n    }\n\n    setupNodeRemap(setupNodeData);\n  }\n\n  parents.set(parent, { ...parentData, enabledNodes: enabledNodeRecords });\n\n  config.remapFinished(parentData);\n}\n\nexport function remapFinished() {\n  if (state) {\n    state.preventEnter = false;\n    state.swappedNodeValue = undefined;\n  }\n}\n\nexport function handleDragstart<T>(data: NodeEventData<T>) {\n  if (!(data.e instanceof DragEvent)) return;\n\n  dragstart({\n    e: data.e,\n    targetData: data.targetData,\n  });\n}\n\nexport function dragstartClasses(\n  el: HTMLElement | Node | Element,\n  draggingClass: string | undefined,\n  dropZoneClass: string | undefined\n) {\n  addClass([el], draggingClass);\n\n  setTimeout(() => {\n    removeClass([el], draggingClass);\n\n    addClass([el], dropZoneClass);\n  });\n}\n\nexport function initDrag<T>(eventData: NodeDragEventData<T>): DragState<T> {\n  const dragState = setDragState(dragStateProps(eventData.targetData));\n\n  if (eventData.e.dataTransfer) {\n    eventData.e.dataTransfer.dropEffect = \"move\";\n\n    eventData.e.dataTransfer.effectAllowed = \"move\";\n\n    eventData.e.dataTransfer.setDragImage(\n      eventData.targetData.node.el,\n      eventData.e.offsetX,\n      eventData.e.offsetY\n    );\n  }\n\n  return dragState;\n}\n\nfunction validateDragHandle<T>(data: NodeEventData<T>): boolean {\n  if (!(data.e instanceof DragEvent) && !(data.e instanceof TouchEvent))\n    return false;\n\n  const config = data.targetData.parent.data.config;\n\n  if (!config.dragHandle) return true;\n\n  const dragHandles = data.targetData.node.el.querySelectorAll(\n    config.dragHandle\n  );\n\n  if (!dragHandles) return false;\n\n  const coordinates = eventCoordinates(data.e);\n\n  const elFromPoint = config.root.elementFromPoint(\n    coordinates.x,\n    coordinates.y\n  );\n\n  if (!elFromPoint) return false;\n\n  for (const handle of Array.from(dragHandles)) {\n    if (elFromPoint === handle || handle.contains(elFromPoint)) return true;\n  }\n\n  return false;\n}\n\nfunction touchstart<T>(data: NodeTouchEventData<T>) {\n  if (!validateDragHandle(data)) {\n    data.e.preventDefault();\n\n    return;\n  }\n\n  const touchState = initTouch(data);\n\n  handleTouchedNode(data, touchState);\n\n  handleLongTouch(data, touchState);\n}\n\nexport function dragstart<T>(data: NodeDragEventData<T>) {\n  if (!validateDragHandle(data)) {\n    data.e.preventDefault();\n\n    return;\n  }\n\n  const config = data.targetData.parent.data.config;\n\n  const dragState = initDrag(data);\n\n  const originalZIndex = data.targetData.node.el.style.zIndex;\n\n  dragState.originalZIndex = originalZIndex;\n\n  data.targetData.node.el.style.zIndex = \"9999\";\n\n  dragstartClasses(\n    dragState.draggedNode.el,\n    config.draggingClass,\n    config.dropZoneClass\n  );\n}\n\nexport function handleTouchOverNode<T>(e: TouchOverNodeEvent<T>) {\n  if (!state) return;\n\n  if (state.draggedNode.el === e.detail.targetData.node.el) return;\n\n  if (e.detail.targetData.parent.el === state.lastParent.el)\n    sort(e.detail, state);\n  else transfer(e.detail, state);\n}\n\nexport function setupNode<T>(data: SetupNodeData<T>) {\n  const config = data.parentData.config;\n\n  data.node.draggable = true;\n\n  data.nodeData.abortControllers.mainNode = addEvents(data.node, {\n    dragstart: nodeEventData(config.handleDragstart),\n    dragover: nodeEventData(config.handleDragoverNode),\n    dragend: nodeEventData(config.handleEnd),\n    touchstart: nodeEventData(config.handleTouchstart),\n    touchmove: nodeEventData(config.handleTouchmove),\n    touchend: nodeEventData(config.handleEnd),\n    touchOverNode: config.handleTouchOverNode,\n  });\n\n  config.reapplyDragClasses(data.node, data.parentData);\n\n  // TODO: setupNode should maybe accept argument saying whether or not to\n  // add events\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.setupNode?.(data);\n  });\n}\n\nexport function setupNodeRemap<T>(data: SetupNodeData<T>) {\n  nodes.set(data.node, data.nodeData);\n\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.setupNodeRemap?.(data);\n  });\n}\n\nfunction reapplyDragClasses<T>(node: Node, parentData: ParentData<T>) {\n  if (!state) return;\n\n  const dropZoneClass =\n    \"touchedNode\" in state\n      ? parentData.config.touchDropZoneClass\n      : parentData.config.dropZoneClass;\n\n  if (state.draggedNode.el !== node) return;\n\n  addClass([node], dropZoneClass, true);\n}\n\nexport function tearDownNodeRemap<T>(data: TearDownNodeData<T>) {\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.tearDownNodeRemap?.(data);\n  });\n}\n\nexport function tearDownNode<T>(data: TearDownNodeData<T>) {\n  data.parentData.config.plugins?.forEach((plugin: DNDPlugin) => {\n    plugin(data.parent)?.tearDownNode?.(data);\n  });\n\n  data.node.draggable = false;\n\n  if (data.nodeData?.abortControllers?.mainNode) {\n    data.nodeData?.abortControllers?.mainNode.abort();\n  }\n}\n\nexport function handleEnd<T>(eventData: NodeEventData<T>) {\n  if (!state) return;\n\n  end(eventData, state);\n\n  resetState();\n}\n\nexport function end<T>(\n  _eventData: NodeEventData<T>,\n  state: DragState<T> | TouchState<T>\n) {\n  if (\"longTouchTimeout\" in state && state.longTouchTimeout)\n    clearTimeout(state.longTouchTimeout);\n\n  const config = parents.get(state.initialParent.el)?.config;\n\n  const isTouch = \"touchedNode\" in state;\n\n  const dropZoneClass = isTouch\n    ? config?.touchDropZoneClass\n    : config?.dropZoneClass;\n\n  if (state.originalZIndex !== undefined)\n    state.draggedNode.el.style.zIndex = state.originalZIndex;\n\n  addClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass,\n    true\n  );\n\n  removeClass(\n    state.draggedNodes.map((x) => x.el),\n    dropZoneClass\n  );\n\n  if (config?.longTouchClass) {\n    removeClass(\n      state.draggedNodes.map((x) => x.el),\n      state.initialParent.data?.config?.longTouchClass\n    );\n  }\n\n  if (\"touchedNode\" in state) {\n    state.touchedNode?.remove();\n\n    if (state.scrollParent) {\n      state.scrollParent.style.overflow = state.scrollParentOverflow || \"\";\n    }\n  }\n}\n\nexport function handleTouchstart<T>(eventData: NodeEventData<T>) {\n  if (!(eventData.e instanceof TouchEvent)) return;\n\n  touchstart({\n    e: eventData.e,\n    targetData: eventData.targetData,\n  });\n}\n\nexport function initTouch<T>(data: NodeTouchEventData<T>): TouchState<T> {\n  data.e.stopPropagation();\n\n  const clonedNode = data.targetData.node.el.cloneNode(true) as HTMLElement;\n\n  const rect = data.targetData.node.el.getBoundingClientRect();\n\n  const touchState = setTouchState(\n    setDragState(dragStateProps(data.targetData)),\n    {\n      touchStartLeft: data.e.touches[0].clientX - rect.left,\n      touchStartTop: data.e.touches[0].clientY - rect.top,\n      touchedNode: clonedNode,\n      touchMoving: false,\n    }\n  );\n\n  return touchState;\n}\n\nexport function handleTouchedNode<T>(\n  data: NodeTouchEventData<T>,\n  touchState: TouchState<T>\n) {\n  touchState.touchedNodeDisplay = touchState.touchedNode.style.display;\n\n  const rect = data.targetData.node.el.getBoundingClientRect();\n\n  touchState.touchedNode.style.cssText = `\n            width: ${rect.width}px;\n            position: absolute;\n            pointer-events: none;\n            top: -9999px;\n            z-index: 999999;\n            display: none;\n          `;\n\n  document.body.append(touchState.touchedNode);\n\n  copyNodeStyle(data.targetData.node.el, touchState.touchedNode as Node);\n\n  touchState.touchedNode.style.display = \"none\";\n}\n\nexport function handleLongTouch<T>(\n  data: NodeEventData<T>,\n  touchState: TouchState<T>\n) {\n  const config = data.targetData.parent.data.config;\n\n  if (!config.longTouch) return;\n\n  touchState.longTouchTimeout = setTimeout(() => {\n    if (!touchState) return;\n\n    touchState.longTouch = true;\n\n    const parentScroll = getScrollParent(touchState.draggedNode.el);\n\n    if (parentScroll) {\n      touchState.scrollParent = parentScroll;\n\n      touchState.scrollParentOverflow = parentScroll.style.overflow;\n\n      parentScroll.style.overflow = \"hidden\";\n    }\n\n    if (config.longTouchClass && data.e.cancelable)\n      addClass(\n        touchState.draggedNodes.map((x) => x.el),\n        config.longTouchClass\n      );\n\n    data.e.preventDefault();\n\n    document.addEventListener(\"contextmenu\", function (e) {\n      e.preventDefault();\n    });\n  }, config.longTouchTimeout || 200);\n}\n\nexport function handleTouchmove<T>(eventData: NodeTouchEventData<T>) {\n  if (!state || !(\"touchedNode\" in state)) return;\n\n  touchmove(eventData, state);\n}\n\nfunction touchmoveClasses<T>(\n  touchState: TouchState<T>,\n  config: ParentConfig<T>\n) {\n  if (config.longTouchClass)\n    removeClass(\n      touchState.draggedNodes.map((x) => x.el),\n      config?.longTouchClass\n    );\n\n  if (config.touchDraggingClass)\n    addClass([touchState.touchedNode], config.touchDraggingClass);\n\n  if (config.touchDropZoneClass)\n    addClass(\n      touchState.draggedNodes.map((x) => x.el),\n      config.touchDropZoneClass\n    );\n}\n\nfunction moveTouchedNode<T>(\n  data: NodeTouchEventData<T>,\n  touchState: TouchState<T>\n) {\n  touchState.touchedNode.style.display = touchState.touchedNodeDisplay || \"\";\n\n  const x = data.e.touches[0].clientX + window.scrollX;\n\n  const y = data.e.touches[0].clientY + window.scrollY;\n\n  const windowHeight = window.innerHeight + window.scrollY;\n\n  // TODO: Make this more dynamic.\n  if (y > windowHeight - 50) {\n    window.scrollBy(0, 10);\n  } else if (y < window.scrollY + 50) {\n    window.scrollBy(0, -10);\n  }\n\n  const touchStartLeft = touchState.touchStartLeft ?? 0;\n\n  const touchStartTop = touchState.touchStartTop ?? 0;\n\n  touchState.touchedNode.style.left = `${x - touchStartLeft}px`;\n\n  touchState.touchedNode.style.top = `${y - touchStartTop}px`;\n}\n\nfunction touchmove<T>(data: NodeTouchEventData<T>, touchState: TouchState<T>) {\n  if (data.e.cancelable) data.e.preventDefault();\n\n  const config = data.targetData.parent.data.config;\n\n  if (config.longTouch && !touchState.longTouch) {\n    clearTimeout(touchState.longTouchTimeout);\n\n    return;\n  }\n\n  if (touchState.touchMoving !== true) {\n    touchState.touchMoving = true;\n\n    touchmoveClasses(touchState, config);\n  }\n\n  moveTouchedNode(data, touchState);\n\n  const elFromPoint = getElFromPoint(data);\n\n  if (!elFromPoint) return;\n\n  if (\n    \"node\" in elFromPoint &&\n    elFromPoint.node.el === touchState.draggedNodes[0].el\n  ) {\n    touchState.lastValue = data.targetData.node.data.value;\n\n    return;\n  }\n\n  const touchMoveEventData = {\n    e: data.e,\n    targetData: elFromPoint,\n  };\n\n  if (\"node\" in elFromPoint) {\n    elFromPoint.node.el.dispatchEvent(\n      new CustomEvent(\"touchOverNode\", {\n        detail: touchMoveEventData,\n      })\n    );\n  } else {\n    elFromPoint.parent.el.dispatchEvent(\n      new CustomEvent(\"touchOverParent\", {\n        detail: touchMoveEventData,\n      })\n    );\n  }\n}\n\nexport function handleDragoverNode<T>(data: NodeDragEventData<T>) {\n  if (!state) return;\n\n  dragoverNode(data, state);\n}\n\nexport function handleDragoverParent<T>(eventData: ParentEventData<T>) {\n  if (!state) return;\n\n  transfer(eventData, state);\n}\n\nexport function handleTouchOverParent<T>(e: TouchOverParentEvent<T>) {\n  if (!state) return;\n\n  transfer(e.detail, state);\n}\n\nexport function validateTransfer<T>(\n  data: ParentEventData<T>,\n  state: DragState<T> | TouchState<T>\n) {\n  if (data.targetData.parent.el === state.lastParent.el) return false;\n\n  const targetConfig = data.targetData.parent.data.config;\n\n  if (targetConfig.dropZone === false) return false;\n\n  const initialParentConfig = state.initialParent.data.config;\n\n  if (targetConfig.accepts) {\n    return targetConfig.accepts(\n      data.targetData.parent,\n      state.initialParent,\n      state.lastParent,\n      state\n    );\n  } else if (\n    !targetConfig.group ||\n    targetConfig.group !== initialParentConfig.group\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction dragoverNode<T>(\n  eventData: NodeDragEventData<T>,\n  dragState: DragState<T>\n) {\n  eventData.e.preventDefault();\n\n  if (\n    dragState.draggedNodes\n      .map((x) => x.el)\n      .includes(eventData.targetData.node.el)\n  )\n    return;\n\n  eventData.targetData.parent.el === dragState.lastParent?.el\n    ? sort(eventData, dragState)\n    : transfer(eventData, dragState);\n}\n\nexport function validateSort<T>(\n  data: NodeDragEventData<T> | NodeTouchEventData<T>,\n  state: DragState<T> | TouchState<T>,\n  x: number,\n  y: number\n): boolean {\n  if (\n    !state ||\n    state.preventEnter ||\n    state.swappedNodeValue === data.targetData.node.data.value ||\n    data.targetData.parent.el !== state.lastParent?.el ||\n    data.targetData.parent.data.config.sortable === false\n  )\n    return false;\n\n  const targetRect = data.targetData.node.el.getBoundingClientRect();\n\n  const dragRect = state.draggedNode.el.getBoundingClientRect();\n\n  const yDiff = targetRect.y - dragRect.y;\n\n  const xDiff = targetRect.x - dragRect.x;\n\n  let incomingDirection: \"above\" | \"below\" | \"left\" | \"right\";\n\n  const range =\n    state.draggedNode.data.index > data.targetData.node.data.index\n      ? [data.targetData.node.data.index, state.draggedNode.data.index]\n      : [state.draggedNode.data.index, data.targetData.node.data.index];\n\n  state.targetIndex = data.targetData.node.data.index;\n\n  state.affectedNodes = data.targetData.parent.data.enabledNodes.filter(\n    (node) => {\n      return (\n        range[0] <= node.data.index &&\n        node.data.index <= range[1] &&\n        node.el !== state.draggedNode.el\n      );\n    }\n  );\n\n  if (Math.abs(yDiff) > Math.abs(xDiff)) {\n    incomingDirection = yDiff > 0 ? \"above\" : \"below\";\n  } else {\n    incomingDirection = xDiff > 0 ? \"left\" : \"right\";\n  }\n\n  const threshold = state.lastParent.data.config.threshold;\n\n  switch (incomingDirection) {\n    case \"left\":\n      if (x > targetRect.x + targetRect.width * threshold.horizontal) {\n        state.incomingDirection = \"left\";\n\n        return true;\n      }\n      break;\n\n    case \"right\":\n      if (x < targetRect.x + targetRect.width * (1 - threshold.horizontal)) {\n        state.incomingDirection = \"right\";\n\n        return true;\n      }\n      break;\n\n    case \"above\":\n      if (y > targetRect.y + targetRect.height * threshold.vertical) {\n        state.incomingDirection = \"above\";\n\n        return true;\n      }\n      break;\n\n    case \"below\":\n      if (y < targetRect.y + targetRect.height * (1 - threshold.vertical)) {\n        state.incomingDirection = \"below\";\n\n        return true;\n      }\n      break;\n\n    default:\n      break;\n  }\n\n  return false;\n}\n\nexport function sort<T>(\n  data: NodeDragEventData<T> | NodeTouchEventData<T>,\n  state: DragState<T> | TouchState<T>\n) {\n  const { x, y } = eventCoordinates(data.e);\n\n  if (!validateSort(data, state, x, y)) return;\n\n  state.swappedNodeValue = data.targetData.node.data.value;\n\n  state.preventEnter = true;\n\n  data.targetData.parent.data.config.performSort(state, data);\n}\n\n/**\n * Event listener used for all nodes.\n *\n * @param e - The event.\n *\n */\nexport function nodeEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function nodeTargetData(node: Node): NodeTargetData<T> | undefined {\n    const nodeData = nodes.get(node);\n\n    const parent = node.parentNode || state?.lastParent?.el;\n\n    if (!nodeData) return;\n\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      node: {\n        el: node,\n        data: nodeData,\n      },\n      parent: {\n        el: parent,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = nodeTargetData(e.currentTarget as Node);\n\n    if (!targetData) return;\n\n    return callback({\n      e,\n      targetData,\n    });\n  };\n}\n\n// TRANSFER LOGIC:\nexport function performTransfer<T>(\n  state: DragState<T> | TouchState<T>,\n  data: NodeEventData<T> | ParentEventData<T>\n) {\n  const draggedValues = dragValues(state);\n\n  const lastParentValues = parentValues(\n    state.lastParent.el,\n    state.lastParent.data\n  ).filter((x: any) => !draggedValues.includes(x));\n\n  const targetParentValues = parentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data\n  );\n\n  const reset =\n    state.initialParent.el === data.targetData.parent.el &&\n    data.targetData.parent.data.config.sortable === false;\n\n  let targetIndex: number;\n\n  if (\"node\" in data.targetData) {\n    if (reset) {\n      targetIndex = state.initialIndex;\n    } else if (data.targetData.parent.data.config.sortable === false) {\n      targetIndex = data.targetData.parent.data.enabledNodes.length;\n    } else {\n      targetIndex = data.targetData.node.data.index;\n    }\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  } else {\n    targetIndex = reset\n      ? state.initialIndex\n      : data.targetData.parent.data.enabledNodes.length;\n\n    targetParentValues.splice(targetIndex, 0, ...draggedValues);\n  }\n\n  setParentValues(state.lastParent.el, state.lastParent.data, lastParentValues);\n\n  setParentValues(\n    data.targetData.parent.el,\n    data.targetData.parent.data,\n    targetParentValues\n  );\n}\n\n/**\n * Used when the dragged element enters into a parent other than its own.\n *\n * @param eventData\n *\n * @param state\n *\n * @internal\n *\n * @returns void\n */\nexport function transfer<T>(\n  data: NodeEventData<T> | ParentEventData<T>,\n  state: DragState<T> | TouchState<T>\n): void {\n  if (!validateTransfer(data, state)) return;\n\n  data.targetData.parent.data.config.performTransfer(state, data);\n\n  state.lastParent = data.targetData.parent;\n}\n\nexport function parentEventData<T>(\n  callback: any\n): (e: Event) => NodeEventData<T> | undefined {\n  function parentTargetData(\n    parent: HTMLElement\n  ): ParentTargetData<T> | undefined {\n    const parentData = parents.get(parent);\n\n    if (!parentData) return;\n\n    return {\n      parent: {\n        el: parent,\n        data: parentData as ParentData<T>,\n      },\n    };\n  }\n\n  return (e: Event) => {\n    const targetData = parentTargetData(e.currentTarget as HTMLElement);\n\n    if (!targetData) return;\n\n    return callback({\n      e,\n      targetData,\n    });\n  };\n}\n"],"mappings":"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","names":["className","state","parentValues","x","parentValues","dragStateProps","state","x","dragstart","touchstart"]}